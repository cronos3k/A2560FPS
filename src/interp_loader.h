/*
 *  Abuse - dark 2D side-scrolling platform game
 *  Copyright (c) 2025 AI-Enhanced Development
 *
 *  This software was released into the Public Domain. As with most public
 *  domain software, no warranty is made or implied.
 */

#ifndef __INTERP_LOADER_HPP_
#define __INTERP_LOADER_HPP_

#include "image.h"
#include "transimage.h"
#include "items.h"
#include "palette.h"
#include <string>
#include <vector>
#include <map>

/**
 * Interpolated Sprite Loader
 *
 * Loads AI-interpolated PNG sprite frames from the filesystem and converts them
 * to the game's internal format. This system provides smooth 60 FPS animations
 * by using 4x interpolated frames generated by the RIFE AI model.
 *
 * Design: Non-destructive parallel system
 * - Original sprite system unchanged
 * - Optional (controlled by settings.interpolated_sprites_enabled)
 * - Loads data from AIWork/frame-interpolation/final/
 */

/**
 * Metadata for a single interpolated frame
 */
struct InterpFrameMetadata
{
    int original_width;
    int original_height;
    int pad_left;
    int pad_top;
    int normalized_width;
    int normalized_height;
    std::string filename;
};

/**
 * Metadata for an entire sprite collection
 */
struct InterpCollectionMetadata
{
    int target_width;
    int target_height;
    std::vector<InterpFrameMetadata> frames;

    bool load_from_json(const char *json_path);
};

/**
 * Interpolated figure - parallel to regular figure but with 4x frames
 */
struct InterpFigure
{
    figure *fig;          // The actual figure with interpolated sprite
    int original_frame;   // Which original frame this interpolates from (0, 1, 2, ...)
    float sub_offset;     // Offset within physics frame (0.0, 0.25, 0.5, 0.75)
};

/**
 * Collection of interpolated figures for one sprite type
 */
class InterpCollection
{
public:
    std::string name;                    // e.g., "bigexp", "aliens"
    std::vector<InterpFigure> figures;   // All interpolated figures
    InterpCollectionMetadata metadata;
    std::map<int, int> original_frame_map; // Map: original frame number â†’ base index in figures vector

    InterpCollection(const char *collection_name);
    ~InterpCollection();

    bool load();                         // Load all PNGs and create figures
    figure *get_interpolated_frame(int physics_frame, float render_offset, int total_physics_frames);

private:
    bool load_png_to_image(const char *png_path, image **out_img, palette *pal);
    figure *create_figure_from_image(image *img, int frame_index);
};

/**
 * Global interpolated sprite manager
 */
class InterpSpriteManager
{
public:
    InterpSpriteManager();
    ~InterpSpriteManager();

    bool is_enabled() const { return enabled; }
    void set_enabled(bool value) { enabled = value; }

    bool initialize();                   // Load all interpolated sprite collections
    void shutdown();                     // Free all interpolated data

    // Get interpolated figure for rendering
    figure *get_interpolated_figure(const char *collection, int physics_frame,
                                   float render_offset, int total_physics_frames);

    // Check if collection has interpolated data
    bool has_interpolated_data(const char *collection) const;

private:
    bool enabled;
    std::vector<InterpCollection*> collections;
    palette *game_palette;               // Reference to game's palette

    InterpCollection *find_collection(const char *name);
    bool load_collection(const char *name);
};

// Global instance
extern InterpSpriteManager *interp_sprite_manager;

// Utility functions
void init_interp_sprites();              // Called at game startup
void shutdown_interp_sprites();          // Called at game shutdown
float get_render_frame_offset();         // Calculate sub-frame timing (0.0-1.0)

#endif // __INTERP_LOADER_HPP_
